// package sdq
package main

import (
    "fmt"
)


//gg


// 13 12 11 10 1
// 1(9)  1
// 2(99)  1,10,11-19 21 31       1X, 10个(10-19)   X1,9个(11-91)                    19
// 3(999)  1xx 100ge(100-199)  x1x 90?([1,9].cnt * [0,9].cnt)  xx1 90ge([1,9]*[0-9])        100+90+90

// x1x  + xx1   ==  x(x1) + x(1x)           x1 x is [1,9]    ax1   x is [0,9]

//   10 + 9*(f(9) + 0)
//         100 +    9*(  f(99) + 1 )


// 1        1
// 10       2           1 + 1
// 100      20      1 + 10 + 9          第一位为1，1条, 第二位为1，10条(10-19),第三位为1,9条(x1, x is [1,9])
// 1000             1 + 99      第一位为1,1条，第二位为1,100条(100-199), 第二位为1,x1x 
// 100000000          第一位为1,1条，  第二位为1 (100..00 - 1999..9) 第二位为1  a1xxxxxxx (a is [1,9], x is [0,9])
//              第三位为1, ax1xxxxxx，a[1,9], x[0,9]
//                ?         a[1,9],x[0,9]   后续都一样的。


// 1       1
// 10      2      1 + 1         
// 100     20     1 + 10 + 9    
// 1000          1 + 100 + 90 + 90
// 10000       1 + 1000 + 900*3
// 100000    1 + 10000 + 9000*4


// 乱。。。



// 1001  至少有 1001/10  个 1      比1000多一个，  和 1002,1009 一样多

// 2341  至少有 2341/10 个 1,
// 但是不知道 前面要不要限制。  需要限制的， 不然  1 会重复计算的，    

// 1001  至少  1个1
// 1011  至少 10个1
// 首位1 需要保留。
// 2001 至少 [100,200]   101个 1    然后变成 200. 200有多少个1？    20-10+1 个1.
// 

// 感觉是从头往后的。



func countDigitOne(n int) int {




    // t2, cnt0 := 1, 0
    // for t2 < n {
    //     t2 *= 10
    //     cnt0++
    // }
    // t2 /= 10
    // cnt0--
    // for n > 0 {
    //     t3 := n / t2

    // }
}

// // 100000   1
// func converta233(cnt0 int) int {
//     ans := 0

// }


func main_LT0233_20211126() {
// func main() {

    fmt.Println("ans:")


}
